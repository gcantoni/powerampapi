<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (C) 2010-2020 Maksim Petrov

Redistribution and use in source and binary forms, with or without
modification, are permitted for themes, skins, widgets, plugins, applications and other software
which communicate with Poweramp music player or Poweramp Equalizer applications on Android platform.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<resources xmlns:tools="http://schemas.android.com/tools">
	<!-- Used in <include>, if true, no any error happens if android:layout doesn't exist (set to @null for that <include>) -->
	<attr name="optional" format="boolean"/>
	
	<!-- Just for Android 8.0, which supports light navigation bar, but doesn't have attribute for that -->
	<attr name="windowLightNavigationBar" format="boolean"/>
	
	<!-- Styles always applied for activities / dialogs -->
	<declare-styleable name="PoweruiStyles">
		<!-- Base styles applied for any activity -->
		<attr name="BasePoweruiStyles" format="reference"/>
		
		<!-- Styles applied for main activity, includes top list widget, items, navbar, etc. styles -->
		<attr name="TopPoweruiStyles" format="reference"/>
	
		<!-- Forced styles for dialogs -->	
		<attr name="DialogForcedStyle"/>
		
		<!-- Forced style for case when light system ui (navigation/status bar) is needed for light theme.
		     This usually happens in Settings, where Settings theme differs from main app theme, thus, dialogs may change system ui colors --> 
		<attr name="DialogForceLightSystemUIStyle"/>
		<!-- Forced style for case when dark system ui (navigation/status bar) is needed for light theme.
		     This usually happens in Settings, where Settings theme differs from main app theme, thus, dialogs may change system ui colors --> 
		<attr name="DialogForceDarkSystemUIStyle"/>
	</declare-styleable>
	
	
	<!-- Base PowerList attributes. NOTE: main Poweramp list is a ListWidget (derived from PowerList) which has extra attributes (see ListWidget below) -->
	<declare-styleable name="PowerList">
		<!-- ListScroller view id. PowerList uses separate view as scrollbar -->
		<attr name="listScroller" format="reference"/>
		<!-- ListIndexer view id. PowerList uses separate indexer view (small popup with character for a-z scrolling) -->
		<attr name="listIndexer" format="reference"/>
		
		<attr name="moveableToolbar" format="reference"/><!-- Id of the toolbar which can be moved by list on scroll -->
		<attr name="moveableToolbarExtraStates" format="boolean"/><!-- If true, PowerList will set state w:state_toolbar_in_header for NavBar and NavBarButtons drawables when toolbar is over header -->
		<attr name="moveableToolbarAnchor">
			<enum name="fixedTop" value="0"/><!-- Toolbar always on top, doesn't move (also should be set in xml layout as top aligned) -->
			<enum name="top" value="1"/><!-- Toolbar moves away top on scroll (also should be set in xml layout as top aligned) -->
			<enum name="bottom" value="2"/><!-- Toolbar moves away bottom on scroll (also should be set in xml layout as bottom aligned) -->
			<enum name="fixedBottom" value="3"/><!-- Toolbar always on bottom, doesn't move (also should be set in xml layout as bottom aligned) -->
		</attr>
		
		<!-- Space to reserve for moveable toobar on bottom. Should be large enough so toolbar doesn't overlap last item -->
		<attr name="bottomReservedSpace" format="dimension"/>

		<!-- Not used ATM. 
		     Space to reserve for selection bar on bottom. Should be large enough so selection doesn't overlap last item.
		     @deprecated use selectionBottomReservedExtraSpace instead -->
		<attr name="selectionBottomReservedSpace" format="dimension"/>

		<!-- The extra space to add to bottomReservedSpace for a selection mode. Allows space increase/decrease relative to bottomReservedSpace, 
		     which can be dynamic due to the theme options  --> 	
		<attr name="selectionBottomReservedExtraSpace" format="dimension"/>
		
		<attr name="android:colorEdgeEffect"/><!-- Defines overshoot edge effect color -->
	</declare-styleable>
	
	<!-- Extra state for drawables -->
	<attr name="state_toolbar_in_header" format="boolean" /><!-- REVISIT: not used ATM -->
		
	
	<!-- Scene params is a pseudo-view-tag (xml tag without the actual view) which defines attributes for one or multiple scenes -->
	<declare-styleable name="SceneParams">
		<!-- If visibility is missing from the given SceneParams, visibility is not changed -->
		<attr name="android:visibility"/>
		
		<!-- NOTE: manipulating visibility, alpha + StateAnim alpha is hard, and some scenarios may not work properly due to the conflicting or overlapping alpha values --> 
	
		<!-- If alpha is missing from the SceneParams, alpha=1.0 is assumed -->
		<attr name="android:alpha"/>

		<!-- Uniform scale. Separate scaleX/Y are not supported.
			 If scale is missing from the SceneParams, scale=1.0 is assumed -->
		<attr name="scale" format="float"/>
		
		<!-- Elevation is applied with a "jump", as animated elevation change has large overhead. 
			 Appropriate outline provider and other required elevation properties should be set on view.
			 If elevation is missing from the SceneParams, elevation value is kept as is.
			 Due to the high overhead for elevation changes, this property behavior, thus, differs from other SceneParams attributes like scale or alpha) -->
		<attr name="android:elevation"/>
		
		<!-- Optional attribute, if missing, SceneParams is attached to the previous view -->
		<attr name="forId" format="reference|integer">
			<!-- NOTE: parent generally won't work when SceneParams is put into the same XML layout which defines "parent", as during XML inflation,
				 that "parent" is not yet attached to the upper parent, thus it's not possible to create layout params for it and it's not possible
				 to create SceneParams.
				 "parent" is used for loadable / merged XML layouts, when extra SceneParams should be added to parent view, where XML is added to
			--> 
			<enum name="parent" value="0"/>
			<!-- These SceneParams is for RootView (window top view group). Very special case, used e.g. for dialogs -->
			<enum name="root" value="-1"/>
		</attr>
		
		<!-- Target scene id which this SceneParams is for -->
		<attr name="scene" format="reference|integer">
			<!-- NOTE: scene can be set to defaultScene, so that will redefine the default scene (or update, if baseScene="defaultScene" is used 
				 Only first "scene" attribute supports this -->
			<enum name="defaultScene" value="0"/>
		</attr>
		<attr name="scene_2" format="reference"/><!-- valid only if scene exists in tag -->
		<attr name="scene_3" format="reference"/><!-- valid only if scene_2 exists in tag -->
		<attr name="scene_4" format="reference"/><!-- valid only if scene_3 exists in tag -->
		<attr name="scene_5" format="reference"/><!-- valid only if scene_4 exists in tag -->
		<attr name="scene_6" format="reference"/><!-- valid only if scene_5 exists in tag -->
		
		<!-- Base scene we copy all the properties from. Usually, using baseScene is better VS using parent styles, as
			 parent styles still require full parsing and processing, and baseScene just copies base scene values -->
		<attr name="baseScene" format="reference|integer">
			<enum name="defaultScene" value="0"/>
		</attr>
		
		<!-- NOTE: placed here for technical reasons to detect if layout params exist for the given scene params.
			 If layout_width exists in the attributes, we assume layout is set for this scene params, otherwise no different layout is applied for this scene params -->
		<attr name="android:layout_width"/>
		
		<!-- Defines point during transition when target view is re-laid out. Layout is a costly operation for the most views,
		     so we want to keep it as rare as possible, still getting smooth animation.
		     NOTE: this option changes only "layout" processing in terms of Android UI framework. 
		     The bounds of views are always transitioned/animated (unless view is GONE) -->
		<attr name="recalcChildren" format="fraction|integer">
			<!-- Initial child layout is used for the transition until end (jumps in the end) -->
			<enum name="on_end" value="0" /><!-- Sync with SceneParams --> 
			
			<!-- Final child layout is used for the transition (jumps in the beggining) -->
			<enum name="on_start" value="1" /><!-- Sync with SceneParams -->
			 
			<!-- Dynamically recalculate layout of children, this is costly and can be slow, but may be required for images and some other views that
			     we want to constantly relayout during transition -->
			<enum name="dynamic" value="2" /><!-- Sync with SceneParams -->
		</attr>
		
		<!-- Default is true. Used to disable existing scene, e.g. _tag_scene_zero -->
		<attr name="applyScene" format="boolean"/>
		
		<!-- Default is false for non-zero/default scene and true for zero/default scene. 
		     If true, per view params will be applied for this scene (if supported by view), such as background, textColor, etc. -->
		<attr name="applyViewParams" format="boolean"/> 
		
		<!-- Default is false. If true, visibility will be applied immediately without an alpha transition. Good for the cases when view should not fade at all -->
		<attr name="jumpVisibility" format="boolean"/>
		
		<!-- If true, apply scene params even if view is GONE in _both_ (from/to) scenes. 
		     Useful for the views which are force-hidden by code, but still should have different layout in scenes.
		     This can be further optimized with dontApplyIfGone -->
		<attr name="applyEvenIfGone" format="boolean|integer">
			<!-- Don't apply scene params if view is GONE currently (only in the current scene). If view is GONE, then it won't participate in scenes until set to non-gone by code.
			     This is used mostly by views which can be shown/hidden by code -->
			<enum name="dontApplyIfGone" value="2"/>
		</attr>
	</declare-styleable>
	
	
	<!-- StateAnim is pseudo-view-tag that defines animation attribures, orthogonal to Scene animated params, used for small temporary animations -->
	<declare-styleable name="StateAnimParams">
		<!-- Target view id -->
		<attr name="forId"/>
		<!-- State animation id -->
		<attr name="stateAnim" format="reference" />
		<!-- State animation id, valid if stateAnim is defined -->
		<attr name="stateAnim_2" format="reference" />
		<!-- State animation id, valid if stateAnim_2 is defined -->
		<attr name="stateAnim_3" format="reference" />
		<!-- State animation id, valid if stateAnim_3 is defined -->
		<attr name="stateAnim_4" format="reference" />

		<!-- Duration in ms -->		
		<attr name="android:duration"/>
		
		<!-- Target alpha. NOTE: if view is also transitioned by SceneParams with alpha, SceneParams alpha make take priority in some cases -->
		<attr name="android:alpha"/>
		<!-- Sets both scaleX and scaleY to same value. Has priority over separate scaleX/Y values -->
		<attr name="scale"/>
		<!-- Other params, animating the standard Android view transform properties -->
		<attr name="android:scaleX"/>
		<attr name="android:scaleY"/>
		<attr name="android:translationX"/>
		<attr name="android:translationY"/>
		<attr name="android:rotation"/>
		<attr name="android:rotationX"/>
		<attr name="android:rotationY"/>
	</declare-styleable>
	
	<!-- Used internally -->	
	<declare-styleable name="ViewTag">
		<attr name="android:id" />
		<attr name="android:value" />
	</declare-styleable>
	
	<!-- Used internally -->
	<declare-styleable name="Include">
		<attr name="android:id" />
		<attr name="android:visibility" />
		<attr name="android:layout_width"/>
	</declare-styleable>
	
	<!-- Used internally -->
	<declare-styleable name="TextPropsMin">
		<attr name="android:textSize"/>
		<attr name="android:textColor"/>
	</declare-styleable>
	
	<declare-styleable name="TextSizeMin">
		<!-- 
		     Some preference key containing float size _multiplier_ id, for example, from skin seekbar preference id. 
		     The multipler is applied to android:textSize set for given textview or other view with the text.

		     Resulting text size in pixels will be:
		       android:textSize in dp * textSizePref preference float value
		       or
		       android:textSize in sp * user system text size preference * textSizePref preference float value.
		       
		     Different text or view styles may have different textSizePref values. We use multiplier here instead of the fixed font size value
		     to allow all the default text sizes (defined by default themes) to be valid without extra configuration.
		     
		     NOTE: the value should be some id in the format "@id/your_id_name"
		-->
		<attr name="textSizeMultiplierPref" format="reference"/>
	</declare-styleable>
	
	<!-- Used internally -->
	<!-- NOTE: similar to TextProps, but has no android:textAppearance -->
	<!-- NOTE: there is already TextAppearance styleable from appcompat, so using own version here with the different name -->
	<declare-styleable name="TextAppearanceMin">
		<attr name="android:textSize" />
		<attr name="android:textColor" />
		<attr name="android:textStyle" />
		<attr name="android:typeface" />
		<attr name="android:fontFamily" />
		<attr name="android:textAllCaps"/>
		<attr name="textSizeMultiplierPref"/>
	</declare-styleable>
	
	<declare-styleable name="TextViewFontFamily">
		<attr name="android:textAppearance"/>
		<attr name="android:fontFamily" />
		<attr name="textSizeMultiplierPref"/>
	</declare-styleable>
	
	<!-- Simple view which applies disabledAlpha when disabled -->
	<declare-styleable name="AlphaDisabledView">
		<!-- Defines the disabled alpha value -->	
		<attr name="android:disabledAlpha"/>
	</declare-styleable>
	
	<!-- FastTextView is TextView/Button/ImageButton replacement, which is designed for layout and drawing performance. Used for a static text, labels, text with icons,
		 and just icons (+ few derived classes e.g. for the checkboxes)
		 
		 This is, in some parts, very limited widget, esp. compared to full blown TextView, but it's fast:
		 - it doesn't use Android text layout code
		 - it doesn't support Spanned text 
		 - it doesn't support RTL
		 - it has limited drawable support (just one drawable. Can be positioned to the left, right or top)
		 
		 Nevertheless, additional features are:
		 - support for line drawables (per line text background, independent from general view background)
		 - support for additional animatable SceneParams parameters: text color, max lines, drawable, line background, background 

		 Paddings:
		 NOTE: fast text padding processing (with drawable) differs from the standard Android TextView.
		 This is due to the requirement for consinstent padding around text, while padding around drawable may be specific to that drawable.
		 This allows same styles for buttons with or without drawables and consinstent text paddings as a result  

		 Horizontal FastTextView paddings when no drawable:
		   paddingLeft text paddingRight

		 Horizontal FastTextView paddings when drawable is available, drawablePosition=left:
		   drawablePaddingStart drawable drawablePadding paddingLeft text paddingRight

		 Horizontal FastTextView paddings when drawable is available, drawablePosition=right:
		   paddingLeft text paddingRight drawablePadding drawable drawablePaddingStart

		 Horizontal FastTextView paddings when drawable is available and drawableOnly=true:
		   drawablePaddingStart drawable drawablePadding paddingLeft paddingRight
		   
		 NOTE: when drawablePosition=GRAVITY (this is default for drawableOnly), no paddings applied as fixed size is assumed   
		   
		 Same approach is used for vertical paddings (drawblePosition=top)
		 
		 Paddings with drawablePosition=forceGravity and drawableOnly=true (icon only) are standard paddingLeft/Top/Right/Bottom.
		 drawablePadding/drawablePaddingStart are ignored, as gravity make drawable to be positioned everywhere depending on gravity, thus
		 text-related drawable paddings make no sense in this mode
		 
		 NOTE: generally, some drawables, like <inset> or other drawables with padding can override view paddings completely, when set for FastText/FastButton
		 AFTER initial XML parsing (e.g. during scene animation with the new background)
		 Fast text mitigates this by forcing the initial, XML paddings when background is updated for scene 
	-->
	<declare-styleable name="FastTextView">
		<attr name="lineBackground" format="reference|color"/>
		<!-- If true, text won't be shown and drawablePosition is set to "forceGravity". Good for drawable without text, e.g. image buttons 
			 Default=false -->
		<attr name="drawableOnly" format="boolean"/>
		<!-- Max number of lines in this view. If set to 1, single line mode is activated, similar to android TextView singleLine:
			 - no any breaks are possible, even \n doesn't break text
			 - overflowing text is cut by character, not by word
		-->
		<attr name="android:maxLines"/>
		<!-- NOTE: for compability reasons, singleLine=true just forces maxLines=1 (actual maxLines attribute is then ignored)-->
		<attr name="android:singleLine"/>
		
		<!-- If true, no attempt to break text (on new line/overflow) will happen --> 
		<attr name="noBreak" format="boolean"/>
		<!-- Optional drawable -->
		<attr name="android:drawable"/>
		<!-- Padding before drawable when drawable is available. Can be negative. NOTE: paddingLeft is not applied to drawable (always applied to the text)-->
		<attr name="drawablePaddingStart" format="dimension"/>
		<!-- Padding between drawable and text. Basically it's added to paddingLeft when drawable exists -->
		<attr name="android:drawablePadding"/>
		<attr name="drawablePosition">
			<enum name="left" value="0"/>
			<enum name="top" value="1"/>
			<enum name="right" value="2"/>
			<!-- Drawable will be positioned according to android:gravity. This makes sense only if drawableOnly=true, for pure icons without text. No paddings applied, fixed size assumed -->
			<enum name="forceGravity" value="-1"/>
		</attr>
		<!-- NOTE: android:drawableTint not supported by Android 5.0, thus using w:drawableTint -->
		<attr name="drawableTint" format="reference|color"/>
		<!-- Forced drawable width. Default is drawable original width -->
		<attr name="drawableWidth" format="dimension"/>
		<!-- Forced drawable height. Default is drawable original height -->
		<attr name="drawableHeight" format="dimension"/>
		
		<!-- Default is false. If true, allow this view to have zero-height if no text (text=="" or null) nor drawable is set for it.
		     NOTE: minHeight is still honored -->
		<attr name="allowZeroHeight" format="boolean"/>
		<!-- Extra drawable padding right when no text exists (empty or null). This can be negative value, it's summed with other paddings right to the drawable, i.e:
		     drawablePaddingStart drawable (drawablePaddingEndNoText + drawablePadding + paddingLeft + paddingRight) -->
		<attr name="drawablePaddingEndNoText" format="dimension"/>
		
		<!-- 
		When drawable exists, paddings and backgrounds are distributed as follows:
		  (bg starts) drawablePaddingStart <drawable> drawablePadding (line bg starts) paddingLeft <text> paddingRight (line bg ends) (bg ends)
		When no drawable, paddings are as usual:
		  (bg starts)(line bg starts) paddingLeft <text> paddingRight (line bg ends)(bg ends)
		-->
		
		<!-- Only "none" and "end" are supported ATM -->
		<attr name="android:ellipsize"/>
		<!-- Only "none" and "characters" are supported ATM. It's preferable to use textAllCaps instead, as it's derived from TextAppearance -->
		<attr name="android:capitalize"/>
		<attr name="android:minWidth"/>
		<attr name="android:minHeight"/>
 		<attr name="textScale" format="float"/>
 		<attr name="android:enabled"/>
 		<!-- NOTE: not actually processed by FastTextView, but FastTextView descendants - e.g. FastButton -->
		<attr name="android:disabledAlpha"/>
		
		<attr name="android:text"/>	
		<attr name="android:gravity"/>
		<attr name="android:lineSpacingMultiplier"/>
		<attr name="android:lineSpacingExtra"/>
		
		<attr name="android:textAppearance"/>
		<attr name="android:textSize"/>
		<attr name="android:textColor"/>
		<attr name="android:textStyle"/>
		<attr name="android:textAppearance"/>
		<attr name="android:fontFamily" />
		<attr name="android:typeface" />
		<attr name="android:textAllCaps"/>
		<attr name="textSizeMultiplierPref"/>
	</declare-styleable>
	
	<!-- Scene-overridable extra FastTextView params -->
	<declare-styleable name="FastTextViewSceneParams">
		<attr name="lineBackground"/>
		<attr name="android:textColor" />
		<attr name="android:maxLines"/>
		<!-- NOTE: prior SDK=22 it's not possible to detect @empty (or @null) vs missing attribute.
		     For now, use #00000000 (#0000) color instead to indicate transition to no-background -->
		<attr name="android:background"/>
		<attr name="drawableTint"/>
		<!-- NOTE: limited support for drawable transitions. For the new drawable to appear, default scene should have some default drawable set
			 Basically, that means we can transition between drawables, but we can't transition between no-drawable and drawable and vice-versa -->
		<attr name="android:drawable"/>
		
		<!-- NOTE: supported by MarqueeFastTextView only -->
		<attr name="android:ellipsize"/>
	</declare-styleable>
	
	
	<!-- FastButton is derived from FastTextView -->
	<declare-styleable name="FastButton">
		<!-- Default=false. If false, ripple animation is cancelled, good for cases when button click causes immediate animation/scene transition, and animated
			 ripple is not visible anyway, but causes performance drop on some devices -->
		<attr name="animOnClick" format="boolean"/>
		<attr name="disableClickHandler" format="boolean"/>
	</declare-styleable>
	
	
	<!-- com.maxmpz.widget.base.EditText extension -->
	<declare-styleable name="EditText">
		<attr name="drawableWidth"/>
		<attr name="drawableHeight"/>
	</declare-styleable>
	
	
	<!-- FastCheckBoxOnly is simplified check box, which is View-based (not TextView based, as standard Android checkbox), thus is much-much faster to layout and render
		 in cases when no text is needed (as list items are).
		 Also can be a tristate checkbox
	-->
	<declare-styleable name="FastCheckBoxOnly">
		<attr name="android:drawable"/>
		<attr name="drawableTint"/>
		<attr name="android:checked"/>
		<attr name="tristate" format="boolean"/>
	</declare-styleable>
	
	
	<!-- FastCheckBox is check box with text, based on FastTextView, thus, is faster to layout and render and supports all the FastText additional properties.
		 NOTE: android:button attribute is the same as FastTextView android:drawable, and android:buttonTint is the same as FastTextView drawableTint 
	 -->
	<declare-styleable name="FastCheckBox">
		<!-- <attr name="android:button"/> -->
		<!-- <attr name="android:buttonTint"/> -->
		<attr name="android:checked"/>
	</declare-styleable>
	
	
	<!-- FastLayout (and variants, like SceneFastLayout) is strictly one-pass, one-measure per pass (thus, fast), supporting multiple
		 layout paradigms within single layout, allowing major child layout manipulation with styles without editing actual layout xmls.
		 Most of the design decisions for FastLayout and its FastLayoutParams are dictated by performance. The resulting layouts
		 are faster vs Android basic layouts (LinearLayout/RelativeLayout), much faster than ConstraintLayout, and can be also used
		 as direct replacement even for very simple layouts as FrameLayout due to the minimal overhead
		 
		 FastLayout can replace:
		 - FrameLayout (not slower than FrameLayout, or faster, as FastLayout never re-meassures children for MATCH_PARENT)
		 - LinearLayout (can be implemented via layout_flex* or most commonly via layout_consumeSpace)
		 - RelativeLayout (FastLayout is faster as it uses strictly one-pass, one measure per pass approach) 
		 - partially ConstraintLayout (FastLayout is much faster) 
		 - or combination of those in the one layout
		 
		 Mostly every layout you're seeing in Poweramp main UI is FastLayout
		 
		 FastLayout is focused on performance and thus has limitations due to the strict "no-remeasure" approach:
		 - views are laid out in xml order (some layout params may override the layout direction)
		   - if some view is referenced by other view that triggers immediate laying out of such referenced view
		     - if this causes cycle StackOverflowException is thrown
		 
		 FastLayoutLP are attribures for FastLayout child views. FastLayout itself has no extra attributes
	--> 
	<declare-styleable name="FastLayoutLP">
		<!-- Gravity is applied if no attaching points are defined for the child at given axis 
			 NOTE: FastLayout takes own paddings into account when applying child layout gravity. This is different, from e.g. RelativeLayout 
			 layout_centerInParent/centerHorizontal/centerVertical, which doens't account for the layout own paddings.
		-->
		<attr name="android:layout_gravity" />
		
		<!-- NOTE: layout_*Percent works properly for FastLayout with fixed width/height (i.e. non WRAP_CONTENT)
		     NOTE: layout_*Percent doesn't take consumed space into account and always uses the unmodified parent size.
		     This allows multiple views with same relative size (e.g. 4 views with layout_widthPercent="25%" in a row) also to consume
		     space and being laid out as expeted in a sequence.
		     The views which consume space still my reduce the available size by using -->
		<attr name="layout_widthPercent" format="fraction"/>
		<!-- NOTE: layout_*Percent works properly for FastLayout with fixed width/height (i.e. non WRAP_CONTENT)
		     NOTE: layout_*Percent doesn't take consumed space into account and always uses the unmodified parent size -->
		<attr name="layout_heightPercent" format="fraction"/>
		
		<!-- Defines max possible width for the child -->
		<attr name="layout_maxWidth" format="dimension"/>
		<!-- Defines max possible height for the child -->
		<attr name="layout_maxHeight" format="dimension"/>
		
		<!-- Defines min possible width for the child. Always force applied (compare to view.minWidth which applied only in specific cases) -->
		<attr name="layout_minWidth" format="dimension"/>
		<!-- Defines min possible height for the child. Always force applied (compare to view.minHeight which applied only in specific cases) -->
		<attr name="layout_minHeight" format="dimension"/>
		
		<!-- If set, one view dimension will be matched against another, basically making view square. This works only if the source dimension has defined value, 
			 e.g. fixed dp value, MATCH_PARENT, attachLeft + attachRight, etc.
			 If source dimension is WRAP_CONTENT, layout_matchDimension is ignored.
			 NOTE: appropriate view paddings are added to final view dimensions: padding top/bottom for heightToWidth and padding left/right for widthToHeight -->
		<attr name="layout_matchDimension" format="integer">
			<!-- If set, width dimension will be forced to height, other width attributes are ignored -->
			<enum name="widthToHeight" value="0x100000"/>
			<!-- If set, height dimension will be force to width, other height attributes are ignores --> 
			<enum name="heightToWidth" value="0x200000"/>
		</attr>
		
		<!-- 
			Flex axis views are laid out and expanded (if layout_flexWeight is specified) along the vertical or horizontal axis
			
			NOTE: flex layout views are measured/laid out _before_ any other "normal" children. Thus, if FastLayout width/height is set to WRAP_CONTENT,
			intermediate FastLayout width/height is used for gravity (e.g. gravity=center or gravity=right/bottom), not the final dimensions

			NOTE: any other non-flex w:layout_* properties are ignored for "flex" views 
		-->
		<attr name="layout_flexAxis">
			<enum name="horizontal" value="0x0400"/><!-- NOTE: should match FastLayoutParams.FLAG_FLEX_* -->
			<enum name="vertical" value="0x0800"/>
		</attr>
		
		<!-- 
			NOTE: FastLayout uses weightSum=num of flexWeight children
			Basically this means, layout_flexWeight=1 children always expands uniformely.
			Also, if no layout_flexWeight attribute is specified for a view, it's never stretched/shrinked, just stays as layout_width/height attributes command. 
		--> 
		<attr name="layout_flexWeight" format="float"/>
		
		<!-- If true, this and all next flex views are laid out bottom-up in the xml order -->
		<attr name="layout_flexReverse" format="boolean"/>
		
		<!-- layout_attach* attribute can attach view to:
			 - any other child view, including flex layout child.
			   Cyclic references are not allowed (you'll see stack overflow exception). The referenced view will be laid out first (xml order is ignored).
			 - "parent" attaches to parent side, accounting for any "consumed" space (if any) from side(s) where view is attached or "gravitated" to 
			 - percent value (e.g. 50%) positions view by offset calculated form parent width/height * percent.
			   This works only if appropriate width or height is fixed for the parent FastLayout (i.e. not WRAP_CONTENT).
			 - "inset" - like parent, but offsets by window inset on given side. Makes sense only for parent views which align with
			   the appropriate screen side
			 - "none" - resets any previous value (e.g. set by theme style)
		-->
	 	<!-- layout_attachLeft => attaches left edge of view to right edge of target view or to parent left, or to parent fraction width from left -->
		<attr name="layout_attachLeft" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<enum name="inset" value="-2"/>
		</attr>
		<attr name="layout_attachTop" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<enum name="inset" value="-2"/>
		</attr>
		<attr name="layout_attachRight" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<enum name="inset" value="-2"/>
			<!-- Attaches to the right parent side, calculated prior laying out of this view. If parent has a fixed width, that is the same as "parent",
			     otherwise the right side grows appropriately with every child laid out -->
			<enum name="side" value="-3"/>
		</attr>
		<attr name="layout_attachBottom" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<enum name="inset" value="-2"/>
			<!-- Attaches to the bottom parent side, calculated prior laying out of this view. If parent has a fixed height, that is the same as "parent",
			     otherwise the bottom side grows appropriately with every child laid out -->
			<enum name="side" value="-3"/>
		</attr>
		
		<!-- layout_attachRightToRight => attaches right edge of view to right edge of target view. No fraction or parent here, 
			 as layout_attachRightToRight="fraction %" would be the same as layout_attachRight="fraction %",
			 and layout_attachRightToRight="parent" would be the same as layout_attachRight="parent".
			 layout_attachRightToRight and layout_attachRight are mutually exclusive. The last parsed attribute is in effect.
			 Cyclic references are not allowed (you'll see stack overflow exception). The referenced view will be laid out first (xml order is ignored).
		-->
		 
		<attr name="layout_attachRightToRight" format="reference"/>
		<attr name="layout_attachBottomToBottom" format="reference"/>
		<attr name="layout_attachLeftToLeft" format="reference"/>
		<attr name="layout_attachTopToTop" format="reference"/>
		
		<!-- By default, view gravitates to its parent (via standard android:layout_gravity). If layout_gravityTarget is some non-parent view id, 
			 that target view becomes the point of gravitaion. E.g. if android:layout_gravity="center" and layout_gravityTarget="@id/some_view", this view
			 will be centered relatively to the target "some_view". 
			 The gravity target view should be in the same parent as this view.
			 If gravity target view doesn't exist, or is GONE, view gravitates to parent.
			 Not supported for layout_flex views.
			 Cyclic references are not allowed (you'll see stack overflow exception). The referenced view will be laid out first (xml order is ignored).

			 NOTE: this disables accounting for gravity based consumed parent space, as gravityTarget view bounds become the reference bounds for this view
			 Consume space still works if layout_attach*="parent" is used
		-->
		<attr name="layout_gravityTarget" format="reference|integer">
			<enum name="parent" value="0"/>
		</attr>
		
		<!-- The axis to use for the layout_gravityTarget -->
		<attr name="layout_gravityTargetAxis">
			<enum name="horizontal" value="0x0100"/>
			<enum name="vertical" value="0x0200"/>
			<enum name="both" value="0x0300"/><!-- Default -->
		</attr>
		
		<!-- Applies additional offsets for gravity AND parent available size for this child on appripriate side based on window insets.
		     By default, gravity aligns to the parent sides ignoring possible insets. Also, for match_parent size, %-percent size, or any other parent-related size, no
		     insets are accounted for. With this attribute, appropriate side inset will be accounted.
		     For example, view with layout_offsets=insets and match_parent/match_parent will fill parent according to window insets.
		     This, of course, works if insets are propagated appropriately -->
		<attr name="layout_offsets">
			<flag name="insetLeft"   value="0x10000000"/>
			<flag name="insetTop"    value="0x20000000"/>
			<flag name="insetRight"  value="0x40000000"/>
			<flag name="insetBottom" value="0x80000000"/>
			<!-- All 4 inset sides -->
			<flag name="insets"      value="0xF0000000"/>
		</attr>
		
		
		<!-- layout_consumeSpace "consumes" space within parent from one or two sides, or both (layout_consumeSpace="both").
			 If parent space is consumed, any subsequent child will be laid out with offset. Gravity is also affected, but not the\
			 layout_widthPercent/layout_heightPercent.
			 There are 4 sides in parent view which can be consumed - left, top, right, bottom.
			 
			 Views aligned to left (or left and right), consume left space, view aligned to top - top space, views aligned
			 to right - right space, and aligned to bottom - bottom space.
			 The alignment here means either layout_gravity (per appropiate axis), or layout_attach* attribute, if layout_gravity is missing for the axis.
			 
			 layout_consumeSpace=reset_* resets such layout consumption (works similar to new line in text or to <br/> in html).
			 By default, only the side (e.g. just left, for horizontally consumed space), which view is aligned to is reset. 
			 Special reset_full_* values can reset both sides.
			 
			 For example: 2 columns 50%|50% height=200dp, then 2 rows (width=100%) height=100dp
			 	<view w:layout_widthRelative="50%" android:layout_height="200dp" w:layout_consumeSpace="horizontal"/>
			 	<view w:layout_widthRelative="50%" android:layout_height="200dp" w:layout_consumeSpace="vertical|reset_horizontal"/> 
			 	
			 	<view android:layout_width="match_parent" android:layout_height="100dp" w:layout_consumeSpace="vertical"/>
			 	<view android:layout_width="match_parent" android:layout_height="100dp" w:layout_consumeSpace="vertical"/>
			 
		-->
		<attr name="layout_consumeSpace">
			<flag name="none" value="0"/>
			<flag name="horizontal" value="0x1000000"/><!-- NOTE: should match FastLayoutParams.FLAG_CONSUME_* -->
			<flag name="vertical" value="0x2000000"/>
			<flag name="both" value="0x3000000"/>
			
			<!-- Also consume parent size available for children for width/heightPercent and other parent size dependent proprerties. Size is consumed
			     on the exises we consume space -->
			<flag name="size" value="0x80000000"/>

			<!-- Resets appropriate horizontal consumed space on one side (depending on view gravity, e.g. view attached to left will reset left side consumed space) -->
			<!-- Works like <br/> -->
			<flag name="reset_horizontal" value="0x4000000"/>
			<!-- Resets appropriate vertical consumed space on one side (depending on view gravity, e.g. view attached to top will reset top side consumed space) -->
			<flag name="reset_vertical" value="0x8000000"/>
			<!-- reset_horizontal and reset_vertical combined -->
			<flag name="reset_both" value="0xC000000"/>
	
			<!-- Resets horizontal consumed space on both sides (left/right) -->
			<flag name="reset_full_horizontal" value="0x10000000"/>
			<!-- Resets horizontal consumed space on both sides (top/bottom) -->
			<flag name="reset_full_vertical" value="0x20000000"/>
			
			<!-- Resets horizontal consumed space on all 4 sides (left/right/top/bottom) -->
			<flag name="reset_full" value="0x30000000"/>
			
			<!-- Automatically resets appropriate axis as soon as no more space on this axis exists and consumes other axis on such reset.
				 This results in automatic layout break to new "line" (or column, for vertical layout).
				 E.g. if multiple views have layout_consumeSpace="horizontal|reset_auto", they will be laid out in rows.
				 NOTE: layout_consumeSpace is processed after given view is laid out. Thus, if there is no enough space for view due to consumed space,
				 view will "overshoot" or will be shrinked. Thus, reset_auto works best with predefined percent view dimensions, e.g.
				 multiple views with w:layout_widthPercent="25%" w:layout_consumeSpace="horizontal|reset_auto" will be laid out
				 in rows, 4 view per row
				 NOTE: reset_auto by default resets horizontal axis and consumes vertical.
				 Only if vertical (without also horizontal) is specified for given view, vertical axis will be reset, and horizontal consumed.
				 Other reset_* flags are processed as usual, thus, can cause double consuption and other side effects, if used together with reset_auto
			 -->
			<flag name="reset_auto" value="0x40000000"/>
		</attr>
		
		<!-- android:layout_gravity will be used if layout_forceGravityIfGone="@id/some_view_id" view is missing or GONE --> 
		<attr name="layout_forceGravityIfGone" format="reference"/>
		
		<!-- if any of layout_attach* target ids are "gone", view is attached to appropriate parent side.
			 NOTE: view is attached to parent side if no such target "attach to" view exists, even without this property set to true.
			 layout_consumeSpace attribute is still processed -->
		<attr name="layout_attachToParentIfGone" format="boolean"/>
		
		<!-- View margins are compensated for given scale (thus, margins are not affected by scaleX/scaleY/scale transformations)
			 Requires pivot set to 0, 0 (i.e. android:transformPivotX=0, android:transformPivotY=0). Doesn't work with MATCH_PARENT,
			 though works with attachLeft/attachRight combintation -->
		<attr name="layout_compensateScale" format="float"/>
		
		<!-- If true, view will be given UNSPECIFIED measure spec when view size is wrap_content on given axis.
			 By default, this is disabled, thus view measures requested size limited by its container size. 
			 layout_unlimitedMeasure="true" may be required for the cases when there is only one child view which should grow beyond its container size
			 on the scrollable axis. Such behavior is close to Android ScrollableView children measuring
		-->
		<attr name="layout_unlimitedMeasure" format="boolean"/>
		
		<!-- If true, layout_width/height="wrap_content" won't take margins into account.
		     NOTE: by default, when wrap_content is used, parent still limits view size based on parent available size minus view margins.
		     Setting this attribute to true removes margins from the calculation, making whole space available for the child -->
		<attr name="layout_wrapIgnoresMargins" format="boolean"/>
		
		<!-- If true, applied gravity ignores this view margings. Note that gravity may be applied by one axis, both axises, or none,
		     and margins are ignored for the applied gravity axis. Note that also if no other layout_attach* attributes defined for the axis,
		     gravity is applied on this axis --> 
		<attr name="layout_gravityIgnoresMargins" format="boolean"/>
		
		<!-- If true, this view gets width=0 height=0 (like GONE view) when the view is empty. Actual visibility is not changed.
		     NOTE: currently works only for FastTextView and derived classes
		-->
		<attr name="layout_goneWhenEmpty" format="boolean"/>
				

		<!-- NOTE: basic MarginLayoutParams attrs are needed for programmatic LP creation based on style attr/res. MarginLayoutParams doesn't support that,
			 so FastLayoutLP handles margin parsing on its own
			 NOTE: there is a slight difference for marginStart/End parsing. FastLayout always parses them in supportsRtl=true mode, meaning,
			 if marginStart or marginEnd or both are defined, then marginStart and marginStart are used instead of marginLeft/Right.
			 If only one of the marginStart/End attributes defined, other attribute is considered to be 0 (marginLeft/Right ignored) 
		-->
		
		<attr name="android:layout_width"/>
		<attr name="android:layout_height"/>
		<attr name="android:layout_margin"/>
		<attr name="android:layout_marginLeft"/>
		<attr name="android:layout_marginTop"/>
		<attr name="android:layout_marginBottom"/>
		<attr name="android:layout_marginRight"/>
		<attr name="android:layout_marginStart"/>
		<attr name="android:layout_marginEnd"/>
	</declare-styleable>
	
	<!-- Constant definitions for FastLayoutLP layout_matchDimension. Can be used e.g. via resource specific @integer --> 
	<integer name="layout_matchDimension_widthToHeight" tools:ignore="UnusedResources">0x100000</integer>
	<integer name="layout_matchDimension_heightToWidth" tools:ignore="UnusedResources">0x200000</integer>

	<!-- Generic Scene extra attributes, usually applied to layouts starting with Scene* (e.g. SceneFastLayout) -->
	<declare-styleable name="Scene">
		<!-- Default false. If true, scene allows scene-wide state anims, otherwise only specific per-view StateAnims are possible -->
		<attr name="enableStateAnim" format="boolean"/>
		<attr name="clipChildrenForSceneAnim" format="boolean"/><!-- Default false. NOTE: not used ATM -->
		<!-- Default false. If private, child views are not processed by scenes, initiated outside of this view -->
		<attr name="privateScene" format="boolean"/>
	</declare-styleable>
	
	<!-- Extra scene parameters supported for FastLayout children -->
	<declare-styleable name="SceneFastLayoutViewSceneParams">
		<!-- If true, per view params will be applied for this scene -->
		<attr name="applyViewParams"/>
		<attr name="android:background"/>
		<attr name="android:elevation"/>
	</declare-styleable>
		
	<!-- Used internally -->
	<declare-styleable name="BgTransSceneParams">
		<attr name="android:background"/>
	</declare-styleable>
		
	<!-- Used internally in dialogs. Behavior - pseudo-view-tag which attaches to some real view and modifies its behavior in some way -->
	<declare-styleable name="RootSceneActivityBehavior">
		<attr name="windowIsResizable" format="boolean"/>
	</declare-styleable>
	
	<!-- Used internally in dialogs. Behavior - pseudo-view-tag which attaches to some real view and modifies its behavior in some way -->
	<declare-styleable name="AdjustToSoftKeyboardBehavior">
		<attr name="android:enabled"/>
	</declare-styleable>

	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) 
	     which is able to load specific layout for one or multiple scenes, and unload it later, if needed.
	     Similar to Android Stub view, but is not a view (not visible, doesn't participate in layout/rendering/etc.) -->		
	<declare-styleable name="LoadableBehavior">
		<!-- Defines this loadable behavior id. Used by code to find given behavior --> 
		<attr name="android:id"/>
		<!-- Target layout to inject -->
		<attr name="android:layout"/>
		<!-- Target scene id layout will load for. This is usually not needed and missing, as code decides when to load this behavior instead -->
		<attr name="loadForScene" format="reference"/>
		<attr name="loadForScene_2" format="reference"/>
		<attr name="loadForScene_3" format="reference"/>
		<attr name="loadForScene_4" format="reference"/>
		<attr name="loadForScene_5" format="reference"/>
		<attr name="loadForScene_6" format="reference"/>
		<attr name="loadForScene_7" format="reference"/>
		<!-- Optional insert position. Default is end (views appended to parent, fastest) -->
		<attr name="insertAt" format="integer">
			<!-- Insert at position of behavior. 
				 NOTE: position is recorded when behavior is first parsed, thus, subsequent changes to view hierarchy can move this insert point 
			-->
			<enum name="thisPosition" value="-2"/><!-- Sync with LoadableBehavior -->
			<!-- Add to the end of parent view (default) -->
			<enum name="end" value="-1"/>
			<!-- Insert as first child in the parent view -->
			<enum name="start" value="0"/>
		</attr>
		<!-- Default is "onSceneEnd". NOTE: LoadableBehaviors can be loaded/unloaded directly by code.
			 unload="never" makes LoadableBehavior similar to StubView, but it's not a view and controlled by scenes (or code).
		 -->
		<attr name="unload">
			<!-- Unloads when scene moves away from behavior defined loadForScene* sceneId -->
			<enum name="onSceneEnd" value="0"/><!-- Sync with LoadableBehavior -->
			<!-- Never automatically unloaded (but can be unloaded by code -->
			<enum name="never" value="1"/><!-- Sync with LoadableBehavior -->
		</attr>		
	</declare-styleable>
	
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables sending commands to Poweramp event buses
		 NOTE: also applied to BusActionButton -->
	<declare-styleable name="BusActionBehavior">
		<attr name="busId" format="reference"/><!-- E.g. @id/list (== bus supporting view id) or @id/bus_gui -->
		<attr name="msgId" format="reference"/><!-- E.g. @id/cmd_list_select_all -->
		<attr name="longPressMsgId" format="reference"/><!-- E.g. @id/cmd_list_select_all. Send on long press and (if repeatLongPressPeriod > 0) periodically  -->
		<attr name="longPressEndMsgId" format="reference"/><!-- Sent on long press end. Optional. Only valid if longPressMsgId is set -->
		
		<attr name="repeatLongPressPeriod" format="integer"/><!-- If non zero, repeated longPressMsgId events sent each repeatLongPressPeriod ms -->
		
		<attr name="arg1" format="reference|integer|boolean|float|fraction|dimension|color"><!-- Optional argument #1 -->
			<enum name="checkedState" value="-1"/><!-- If parent view is Chechable, then arg will have checked state (1==checked)) -->
		</attr>
		<attr name="arg2" format="reference|integer|boolean|float|fraction|dimension|color"><!-- Optional argument #2 -->
			<enum name="checkedState" value="-1"/>
		</attr>
		<!-- Optional string argument -->
		<attr name="string" format="string"/>
		
		<!-- Optional confirmation dialog title. Should be set for dialog to show -->
		<attr name="confirmTitle" format="string|reference"/>
		<!-- Optional confirmation dialog text -->
		<attr name="confirmText" format="string|reference"/>
		
		<!-- Optional confirmation dialog title for long press. Should be set for dialog to show -->
		<attr name="longPressConfirmTitle" format="string|reference"/>
		<!-- Optional confirmation dialog text for long press -->
		<attr name="longPressConfirmText" format="string|reference"/>
		
		<!-- Delay for sending message in ms -->
		<attr name="clickDelay" format="integer"/>
		
		<attr name="disableForStateBusId" format="reference"/><!-- See BusDisabledForStateBehavior -->
		<attr name="firstPressToast" format="string|reference"/><!-- If set, toast msg will be shown for first ever press on this button. Preference is stored based on view id -->
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) to enable/disable views based on Poweramp state buses
		 NOTE: also applied to BusActionButton -->
	<declare-styleable name="BusDisabledForStateBehavior">
		<attr name="disableForStateBusId"/><!-- E.g. @id/list -->
		<attr name="disableForStateId" format="reference"/><!-- E.g. @id/state_list_selection_mode -->
		<attr name="disableForStateId_2" format="reference"/><!-- Valid only if stateId defined -->
		<attr name="enableForStateId" format="reference"/><!-- E.g. @id/state_list_selection_mode -->
		<attr name="disableForStateMsgId" format="reference"/><!-- Can match stateIds or can be any other message. When msg received, the appropriate disable/enable ids are checked -->
		<attr name="disableForStateMsgId_2" format="reference"/><!-- Can match stateIds or can be any other message. When msg received, the appropriate disable/enable ids are checked -->
	</declare-styleable>
	
	<!-- Extends BusDisabledForStateBehavior -->
	<declare-styleable name="MorphableBusStateBehavior">
		<attr name="morphWhenState" format="reference"/>
		<attr name="morphDrawable" format="reference"/>
		<attr name="morphMsgId" format="reference"/>
		<attr name="morphArg1" format="integer"/>
		<attr name="morphArg2" format="integer"/>
		<attr name="morphString" format="string"/>
		<attr name="morphLongPressMsgId" format="reference"/>
		<attr name="morphLongPressEndMsgId" format="reference"/>
		<attr name="morphContentDescription" format="string"/>
		<attr name="android:drawable"/>
	</declare-styleable>
	
	<!-- SelectablePopupButtonLayout attributes which define list selection workflow -->  
	<declare-styleable name="BusSelectablePopupButtonLayout">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId" format="reference"/>
		<!-- State id to set buttons to -->
		<attr name="stateId"/>
		<!-- Message id to listen from state bus msgbus and set buttons to arg1 --> 
		<attr name="msgId"/>
		<!-- If true, state bus will be queried on message when received instead of using arg1 for msgId message -->
		<attr name="getStateOnMsg" format="boolean"/>
		
		<!-- If set, arg1 will be overridden for BusActionButtons inside when clicked NOT in popup mode -->
		<attr name="arg1"/>
		<!-- If set, arg2 will be overridden for BusActionButtons inside when clicked NOT in popup mode -->
		<attr name="arg2"/>
		<!-- If set, string will be overridden for BusActionButtons inside when clicked NOT in popup mode -->
		<attr name="string"/>
		
		<!-- Buttons message @id - the same command message id is used for all buttons -->
		<attr name="buttonsMsgId" format="reference"/>
		<!-- Buttons bus id - the same msg bus is used for all buttons -->
		<attr name="buttonsBusId" format="reference"/>
		<!-- Integer-array of arg1 for each button. If defined, this array is used to remap index for the reported selected index -->
		<attr name="buttonsArg1" format="reference"/>
		
		<!-- If defined, BusDisabledForStateBehavior is created for this button layout --> 
		<attr name="disableForStateBusId"/>
		
		<!-- Disabled alpha will be used for given view + BusDisabledForStateBehavior -->
		<attr name="android:disabledAlpha"/>
	</declare-styleable>
		
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which selectes child view based on Poweramp state/msg bus -->
	<declare-styleable name="BusSelectableBehavior">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- State id to set buttons to -->
		<attr name="stateId"/>
		<!-- Message id to listen from state bus msgbus and set buttons to. arg1 is checked for state. arg1 == -1 is ignored (no changes to buttons) --> 
		<attr name="msgId"/>
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables left-right swiping scrolling on a layout.
	     See also AAScrollingBehavior --> 
	<declare-styleable name="BusAAScrollingBehavior">
		<!-- Time to scroll between 2 pages when tab/nav button pressed -->
		<attr name="posScrollAnimTime" format="integer"/><!-- ms -->
		<!-- Time to settle to page when scrolled manually -->
		<attr name="settleAnimTime" format="integer"/><!-- ms -->
		
		<attr name="maxOvershoot"/>
		
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- State id to set buttons to -->
		<attr name="stateId"/>
		<!-- Message id to listen from state bus msgbus and set current page to --> 
		<attr name="msgId"/>
		<!-- Message id to send for on pos changed --> 
		<attr name="onPosChangedMsgId" format="reference"/>
				
		<attr name="android:colorEdgeEffect"/><!-- Defines overshoot edge effect color -->
	</declare-styleable>
	
	<!-- Extra attributes for BusStateEnabledBehavior or BusStateActionButton, which manipulate view enabled state based on state -->
	<declare-styleable name="BusStateEnabled">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		
		<!-- State to retrieve from StateBus -->
		<attr name="stateId" format="reference"/>
		
		<!-- Msg id to listen for state change. If not specified, stateId is used -->
		<attr name="stateMsgId"/>
		
		<attr name="enableByState"><!-- Sync with BusStateEnabledHelper.java -->
			<!-- View is enabled when stateId is boolean and true -->
			<enum name="matchBoolean" value="0"/>
			<!-- View is enabled when stateId is boolean and false -->
			<enum name="dontMatchBoolean" value="1"/>
			<!-- View is enabled when stateId is integer and matches matchArg -->
			<enum name="matchInteger" value="2"/>
			<!-- View is enabled when stateId is integer and doesn't match matchArg -->
			<enum name="dontMatchInteger" value="3"/>
		</attr>
		
		<!-- Used to set matching value for stateEnabledLogic=matchInteger/dontMatchInteger -->
		<attr name="stateMatchArg" format="reference|integer"/>
		
		<!-- If true, when msg is received we still check stateBus instead of looking into msg arg1 as state -->
		<attr name="alwaysCheckState" format="boolean"/>
	</declare-styleable>
		
	<!-- Extra options for BusCheckableStateBehavior, BusCheckableStateHelper, BusCheckBox which allow checking/unchecking view based on state -->  
	<declare-styleable name="BusCheckableStateHelper">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- Boolean state to retrieve from StateBus. May match stateMsgId -->
		<attr name="booleanStateId" format="reference"/>
		<!-- Msg id with the boolean value in arg1 to listen to -->
		<attr name="stateMsgId" format="reference"/>
		<!-- If true, true state == checked, otherwise, false state == checked -->
		<attr name="checkedIfTrue" format="boolean"/>
		<!-- Cmd to issue on check -->
		<attr name="checkCmdId" format="reference"/>
		<!-- Cmd to issue on uncheck -->
		<attr name="uncheckCmdId" format="reference"/>
	</declare-styleable>
	
	<!-- Number of attributes to show formatted text based on Poweramp state buses -->
	<!-- NOTE: not used anymore, use BusStatusText instead -->
	<declare-styleable name="BusStateFormatValue">
		<attr name="android:id"/>
		<attr name="busId"/><!-- E.g. @id/list -->
		<attr name="stateId" format="reference"/><!-- E.g. @id/state_list_selection_count -->
		<attr name="secondaryStateId" format="reference"/><!-- E.g. @id/state_list_selectable_item_count -->
		<!-- String like "Count: %d" or array with multiple values. Array also works with boolean-like values (index=0 - false value, index=1 - true value) -->
		<attr name="format" format="string|reference"/> 
		<attr name="type"><!-- Type of state to format -->
			<enum name="integer" value="0"/>
			<enum name="string" value="1"/>
		</attr>
	</declare-styleable>
	
	<!-- Extra options for BusStatusText which update text based on bus msg/state -->
	<declare-styleable name="BusText">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_2" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_3" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_4" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_5" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_6" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_7" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_8" format="reference"/>
		<!-- String state for label to format/display  -->
		<attr name="labelStateId" format="reference"/>
		<!-- Secondary string state for label to format/display  -->
		<attr name="labelStateId_2" format="reference"/>
		<!-- Format string like "Count: %d" or array with multiple values. Array works for type=integer and also with the boolean-like values 
		     (index=0 - false value, index=1 - true value) -->
		<attr name="labelFormat" format="string|reference"/>
		<!-- Int state for icon to display  -->
		<attr name="iconStateId" format="reference"/>
		<!-- Optional scene in which no updates happen. This view should have SceneParams for such scene -->
		<attr name="noUpdateInScene" format="reference"/>
		<!-- Do not update if transition runs (and view is aware of that, i.e. view is animated by the scene) -->
		<attr name="noUpdateInTransition" format="boolean"/>
		
		<!-- Show the default (android:text) text if state is empty/null -->
		<attr name="defaultTextOnNoState" format="boolean"/>
		
		<attr name="stateType"><!-- Type of state to format -->
			<enum name="string" value="0"/><!-- Default -->
			<enum name="integer" value="1"/>
		</attr>
	</declare-styleable>
	
	<!-- FastButton which is able to start specified Activity -->
	<declare-styleable name="IntentActionButton">
		<attr name="android:action"/>
		<attr name="android:targetClass"/>
		<attr name="string"/><!-- EXTRA_OBJ -->
	</declare-styleable>
		
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) used to implement Poweramp dialogs in a separate activity 
		 NOTE: dialog behavior always have implicit id=@id/behavior_dialog -->
	<declare-styleable name="DialogBehavior">
		<attr name="dialogAltOutScene"/><!-- REVISIT: this is read from Theme, not from behavior styles/attributes -->
	</declare-styleable>
		
	<!-- Empty/invisible view which changes its size depending on params below. Used as anchor for other views -->
	<declare-styleable name="SmartSpacer">
		<!-- Some view within this view parent, which will be queried for existance and visibility=GONE. When view is missing/GONE, heightWhenMissing is forced
			 for this view, otherwise, default height is applied -->
		<attr name="heightTargetId" format="reference"/>
		<!-- The height this view has when heightTargetId is missing/GONE -->
		<attr name="heightWhenMissing" format="dimension"/>
				
		<!-- Some view within this view parent, which will be queried for existance and visibility=GONE. When view is missing/GONE, widthtWhenMissing is forced
			 for this view, otherwise, default width is applied -->
		<attr name="widthTargetId" format="reference"/>
		<!-- The width this view has when widthTargetId is missing/GONE -->
		<attr name="widthWhenMissing" format="dimension"/>
	</declare-styleable>
	
	<!-- ListWidget popup menu animation time -->
	<attr name="popupEnterAnimTime" format="integer"/><!-- ms -->
	<!-- ListWidget popup menu animation time -->
	<attr name="popupExitAnimTime" format="integer"/><!-- ms -->
	<!-- Some top level MenuHelper-enabled layout (poped-out item transformed into menu and attached there) -->
	<attr name="menuPlaceholder" format="reference"/>
	
	<attr name="listItemSize"/>
		
	<!-- Base attributes for poping-out layout, transforming into menu on click/long click -->
	<declare-styleable name="PopupLayout">
		<!-- Default is false, and popup is opened by long click. If true, popup is opened by short click -->
		<attr name="openOnClick" format="boolean"/>
		<!-- Default is true. If true, opening popup temporarily hides other popups/top panels/etc. -->
		<attr name="modal" format="boolean"/>
		<!-- If true, inner scrolling will be activated for popup -->
		<attr name="innerScrolling" format="boolean"/>

		<attr name="popupEnterAnimTime"/><!-- ms -->
		<attr name="popupExitAnimTime"/><!-- ms -->
		<attr name="menuPlaceholder"/>
		
		<!-- Layout to inflate into popup -->
		<attr name="menuItemsLayout" format="reference"/>
		<attr name="closeOnClickInside" format="boolean"/>
		
		<!-- True by default. Disables layout passes in parent scene while in popup mode. This is to avoid jumping views around this view, as the view is detached
		     completely from current parent while in popup mode. Alternatively use private scene layout, or set this to false and not rely on this view layout --> 
		<attr name="disableParentLayoutForPopup" format="boolean"/>
	</declare-styleable>
	
	<!-- Layout looking like button, but transformed to a menu on click/long click -->
	<declare-styleable name="PopupButtonLayout">
		<!-- Default is false, and popup is opened by long click. If true, popup is opened by short click -->
		<attr name="openOnClick"/> 
		<attr name="modal"/>
		<attr name="popupEnterAnimTime"/><!-- ms -->
		<attr name="popupExitAnimTime"/><!-- ms -->
		<attr name="buttonAnimTime" format="integer"/><!-- ms -->
		<attr name="menuPlaceholder"/>
		<!--<attr name="menuItemsLayout"/>--><!-- NOTE: not supported here ATM -->
		
		<!-- Button labels string @array --> 
		<attr name="buttonsLabels" format="reference"/>
		<!-- Button drawables @array -->
		<attr name="buttonsDrawables" format="reference"/>
		
		<!-- Tint is applied to buttons drawables -->
		<attr name="drawableTint"/>
		
		<!-- Button style (e.g. ?PopupButton) -->
		<attr name="buttonStyle" format="reference"/>
		<!-- Button style (e.g. ?PopupButton_scene_button_menu) -->
		<attr name="menuButtonStyle" format="reference"/>
		
		<!-- Default is true -->
		<attr name="closeOnClickInside"/>
		
		<!-- True by default. Disables layout passes in parent scene while in popup mode. This is to avoid jumping views around this view, as the view is detached
		     completely from current parent while in popup mode. Alternatively use private scene layout, or set this to false and not rely on this view layout --> 
		<attr name="disableParentLayoutForPopup"/>
		
		<attr name="toastOnPress" format="reference"/>
	</declare-styleable>
	
	
	<!-- Layout for toasts -->
	<declare-styleable name="ToastFrameLayout">
		<attr name="toastDuration" format="integer"/><!-- ms. This is default value, which is often overridden by code -->
		<attr name="cmdId" format="reference"/><!-- By default - cmd_gui_show_toast -->
		<!-- If set, this layout will queue and show toasts in order. If queueMinMs == 0, toasts will be shown with their duration, otherwise new toast will reduce 
		     previous toast duration to queueMinMs ms -->
		<attr name="queueMinMs" format="integer"/>
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables scrolling in a layout.
	     Scrolling direction is defined by layout android:scrollbars -->
	<declare-styleable name="ScrollingBehavior">
		<attr name="maxOvershoot" format="dimension"/>
		<attr name="disallowParentScroll" format="boolean"/>
		<attr name="noScrollbars" format="boolean"/><!-- If true, avoid enabling scrollbar drawing -->
		
		<attr name="android:colorEdgeEffect"/><!-- Defines overshoot edge effect color -->
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables aa-like horizontal scrolling in a layout.
	     See also BusAAScrollingBehavior -->
	<declare-styleable name="AAScrollingBehavior">
		<attr name="maxOvershoot"/>
	</declare-styleable>
	
	<!-- Poping-out button which is transformed into a PowerList -->
	<declare-styleable name="PopupListLayout">
		<!-- Default is true. If true, opening popup temporarily hides other popups/top panels/etc. -->
		<attr name="modal" format="boolean"/>

		<attr name="popupEnterAnimTime"/><!-- ms -->
		<attr name="popupExitAnimTime"/><!-- ms -->
		<attr name="menuPlaceholder"/>
		
		<!-- PowerList style for list used in popup. Default is @style/PopupListLayoutList -->
		<attr name="popupListStyle" format="reference"/>
		
		<!-- True by default. Disables layout passes in parent scene while in popup mode. This is to avoid jumping views around this view, as the view is detached
		     completely from current parent while in popup mode. Alternatively use private scene layout, or set this to false and not rely on this view layout --> 
		<attr name="disableParentLayoutForPopup"/>
		
		<!-- State bus id for label and messages to listen to -->
		<attr name="stateBusId"/>
		
		<!-- Optional long state to listen to/retrieve from StateBus to change selectedItemStateId -->
		<attr name="selectedItemStateId" format="reference"/>
		
		<!-- Msg id to listen for state change (both selected item and label) -->
		<attr name="stateMsgId" format="reference"/>
		
		<!-- String state for label to display. If not set, label text is not change/updated -->
		<attr name="labelStateId" format="reference"/>
		
		<!-- Optional format string like "Preset: %s". NOTE: only strings supported here -->
		<attr name="labelFormat"/>
				
		<!-- Height of list row -->
		<attr name="listItemSize"/>
	</declare-styleable>

	<!-- FastLayout with an animated line background, which animates view resize -->
	<declare-styleable name="BgAnim">
		<!-- lineBackground animation duration --> 
		<attr name="lineAnimTime" format="integer"/>
		
		<!-- Line background drawable --> 
		<attr name="lineBackground"/>
		
		<!-- Default false. If private, child views are not processed by scenes, initiated outside of this view -->
		<attr name="privateScene" format="boolean"/>
	</declare-styleable>
	
	<!-- Additional attributes for selection menu -->
	<declare-styleable name="SelectionMenuBehavior">
		<attr name="animTime"/><!-- In animation duration -->
		<attr name="animExitTime"/><!-- Optional out animation duration (if not specified, animTime is used for both enter and exit) -->
	</declare-styleable>
	
	<declare-styleable name="RatingBar">
		<attr name="android:enabled"/>
		<!-- The star drawble to use -->
		<attr name="android:drawable"/>
		<!-- The off version of star drawable -->
		<attr name="drawableOff" format="reference"/>
		<attr name="drawableWidth"/>
		<attr name="drawableHeight"/>
		<attr name="drawableTint"/>
		<!-- The animated background -->
		<attr name="lineBackground"/>
		<!-- Can be left (default) / right. Defines horizontal position for stars within rating bar -->
		<attr name="android:gravity"/>
		<attr name="busId"/>
		<attr name="msgId"/>
	</declare-styleable>
	
	<!-- Special top-level layout for poping-out menus. Poping out views are transformed into menu and attached to this layout for a popup duration --> 
	<declare-styleable name="PopupMenuHelper">
		<!--
			Color used to shade contents of the list when some popup menu is shown.
			Used for both color and blue shade types. 
			For color - it's just a color. 
			For blur - it's additional color which is also applied before blur. 
		-->
		<attr name="shadeColor" format="color|reference"/>
		
		<!-- <attr name="shadeType"/> -->
		<!-- <attr name="shadeBlurSubsample"/> --><!-- Subsample scale to improve performance. 0.1 recommended -->
		<!-- <attr name="shadeBlurRadius"/> --><!-- Blur radius -->
		<!-- Defines popup overscan area, e.g. set this when popup menu placeholder layout is placed under status bar (overscan=top), 
			 android navigation bar (overscan=bottom) or both (overscan=top|bottom). 
			 This is used for additional vertical alignment accounting for overscans 
		-->
		<!-- Sync with PopupMenuHelper.java -->
		<!-- NOTE: not used ATM
		<attr name="overscan">
			<flag name="none" value="0"/>
			<flag name="top" value="0x1"/>
			<flag name="bottom" value="0x2"/>
		</attr>
		-->
	</declare-styleable>
	
	<!-- Poping out character shown when user actively scrolls in az mode -->
	<declare-styleable name="ListIndexerPopupView">
		<attr name="indexerPopupMode">
			<enum name="fixed" value="0"/><!-- Popup stays as specified by layout --> 
			<enum name="moveWithThumb" value="1"/><!-- Popup translationY is modified to match scrolling thumb. Appropriate layout should be given in xml (e.g. popup should be on top, aligned right to scrollbar -->
		</attr>
		<!-- Additional margin to apply in moveWithThumb + moving thumb mode. NOTE: applied as translationX -->
		<attr name="thumbModeOffsetX" format="dimension"/>
	</declare-styleable>
	
	<!-- Scroller for main Poweramp list with 2 modes - az chars or standard draggable thumb. PowerList switches modes depending on data it's showing --> 
	<declare-styleable name="ListScrollerView">
		<!-- Drawable for thumb. Can have enter/exit animation -->
		<attr name="android:thumb"/>
		<!-- Track drawable. Enter/exit animation is ignored. Instead, StateAnim is applied -->
		<attr name="android:track"/>
		
		<!-- Like standard android transformPivotX/Y, but expressed as percent -->
		<attr name="transformPivotX_percent" format="fraction"/>
		<attr name="transformPivotY_percent" format="fraction"/>
		
		<!-- Background to use in az scrolling mode -->
		<attr name="azBackground" format="reference|color"/>
		<!-- Touched background to use in az scrolling mode -->
		<attr name="azTouchedBackground" format="reference|color"/>
		<!-- Text scale to use in az scrolling mode -->
		<attr name="azTextScale" format="float"/>
		<!-- If exists, scroll up small drawable will be drawn on top of az -->
		<attr name="azScrollUp" format="reference"/>		
				
		<!-- The characters to use in az scrolling mode. Should be properly sorted -->
		<attr name="azChars" format="string"/><!-- NOTE: also should be defined for main theme, as Pages take it from there -->
		
		<!-- Padding for az scrolling mode -->		
		<attr name="azPaddingLeft" format="dimension"/>
		<!-- Padding for az scrolling mode -->
		<attr name="azPaddingRight" format="dimension"/>
		<!-- Padding for az scrolling mode -->
		<attr name="azPaddingTop" format="dimension"/><!-- NOTE: is azSize is used (valid not @null/@empty value, > 0), then azPaddingTop/azPaddingBottom are ignored, AZ centered -->
		<!-- Padding for az scrolling mode -->
		<attr name="azPaddingBottom" format="dimension"/>

		<!-- Optional size (height) for az scrolling mode. Can be a percentage of available height or direct fixed size -->
		<attr name="azSize" format="dimension|fraction"/>
		
		<!-- Also, android:text* attributes are supported -->
		<!-- NOTE: font size is automatically selected depending on space available in the cells -->
		
		<attr name="android:textAppearance"/>
		<attr name="android:textSize"/>
		<attr name="android:textColor"/>
		<attr name="android:textStyle"/>
		<attr name="android:textAppearance"/>
		<attr name="android:fontFamily" />
		<attr name="android:typeface" />
		<attr name="textSizeMultiplierPref"/>
	</declare-styleable>
	
	<declare-styleable name="RatingBarSceneParams">
		<attr name="android:background"/>
		<attr name="drawableTint"/>
		<!-- NOTE: limited support for drawable transitions. For new drawable to appear, default scene should have some default drawable set
			 Basically, that means we can transition between drawables, but we can't transition between no-drawable and drawable and vice-versa -->
		<attr name="android:drawable"/>
		<attr name="drawableOff"/>
		<attr name="lineBackground"/>
	</declare-styleable>
	
				
	<declare-styleable name="Waveseek">
		<!-- Defines waveseek layout -->
		<attr name="waveLayout" format="integer">
			<enum name="scrollable" value="0"/><!-- Waveseek can be dragged with swipes -->
			<enum name="fixed" value="1"/><!-- Waveseek can't be dragged, progress follows touch -->
		</attr>
	
		<!-- Used only in layout=scrollable mode. Ignored in layout=fixed mode -->
		<attr name="barWidth" format="dimension|enum">
			<enum name="auto" value="-1"/><!-- If auto, matches barBitmap bitmap width -->
		</attr>
		
		<!-- Used for both layout modes. Can be a percentage of barWidth for layut=scrollable -->
		<attr name="barSpacing" format="dimension|fraction"/>
	
		<!-- 
			Defines number of bars in waveseek. The actual wave data set to the Waveseek by Poweramp may be of different size. Waveseek resamples
			incoming data to match numBars.
			
			For layout=fixed mode, this together with barSpacing defines width of bars. 
		 -->
		<attr name="numBars" format="integer"/>
		
		<!-- Minumum bar height. NOTE: min bar height can't be less than largest *barBitmap* width -->
		<attr name="minBarHeight" format="dimension"/>
		
		<!-- 
			Waveseek can draw either simple and fast bars with background and border or drawables 
		 	To the left is elapsedBar* bars/drawables, to the right - just bar*.
		 	If divisor is >=0%, then 2 bars/drawables are drawn - top and bottom. 
		 	Bottom bar is drawn with barColor2/elapsedBarColor2/barDrawable2/elapsedBarDrawable2.
		 	
		 	Center bar is split under cursor (even if cursor doesn't exist) - indicating the seek position.
		-->
			
		<!-- The divisor (empty space) position between top and bottom bars. If < 0%, then just one set of bars drawn --> 
		<attr name="divisor" format="fraction"/>
		<!-- The divisor size (size of the empty space between top and bottom bars) -->
		<attr name="divisorSize" format="dimension"/>
		
		
		<!-- NOTE: bar/elapsedBarColor*, bar/elapsedBarDrawable* / stroke are not used now due to issues on some Android devices. Instead raw bitmaps are used. 
			 See bar/elaspedBarBitmap* for details --> 
		<attr name="barColor" format="color|reference"/><!-- NOTE: not used -->
		<attr name="barColor2" format="color|reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarColor" format="color|reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarColor2" format="color|reference"/><!-- NOTE: not used -->
		<attr name="barStrokeColor" format="color|reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarStrokeColor" format="color|reference"/><!-- NOTE: not used -->
		<!-- If both barDrawable & elapsedBarDrawable are defined, then drawables are drawn, otherwise - bars -->
		<attr name="barDrawable" format="reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarDrawable" format="reference"/><!-- NOTE: not used -->
		<attr name="barDrawable2" format="reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarDrawable2" format="reference"/><!-- NOTE: not used -->
		<!-- If non-zero, rounded corners applied to bars -->
		<attr name="barRoundedCorners" format="dimension"/><!-- NOTE: not used -->
		<attr name="stroke" format="dimension"/><!-- NOTE: not used -->
					
		<!-- NOTE: barBitmap/elapsedBarBitmap/barBitmap2/elapsedBarBitmap2 are specifically crafted bitmaps. Height of the bitmap should be >= width of the bitmap.
			 Bitmap is stretched in a way similar to 9-patch images, but only 3 "patches" used - top, middle, bottom.
			 Top is unstretched, height=width*0.5, bottom is unstretched, height=width*0.5 and reset is stretched middle.
			 
			 This is required as accross Android devices, many can't render 9-patch images reliable and fast, others can't reliable
			 render e.g. RoundRect shapes or other Drawables, thus, the approach with the raw Bitmaps is used here -->

		<!-- Non-yet-elapsed bar (to the right of playing point) --> 			 
		<attr name="barBitmap" format="reference"/>
		<!-- Elapsed bar (to the left of playing point) -->
		<attr name="elapsedBarBitmap" format="reference"/>
		<!-- Optiponal non-yet-elapsed bar (to the right of playing point) - bottom part -->
		<attr name="barBitmap2" format="reference"/>
		<!-- Optiponal elapsed bar (to the left of playing point) - bottom part -->
		<attr name="elapsedBarBitmap2" format="reference"/>		
			
		<!-- Used only in layout=fixed mode. Cursor position in percent of Waveseek width. 50%=center -->
		<attr name="cursorPosition" format="fraction"/>
		<!-- Used only in layout=fixed mode. Cursor absolute offset from cursorPosition -->
		<attr name="cursorOffset" format="dimension"/>
		
		<!-- Cursor activation animation -->
		<attr name="cursorAnimator" format="reference"/>

		<!-- Used only in layout=fixed mode. Default=true. If true, elapsed bars are redrawn immediately on any scroll, otherwise they delayed until scroll is finished -->
		<attr name="cursorBgFastTracking" format="boolean"/><!-- NOTE: not used -->
		
		<!-- If set, all bars will have this value. Useful for emulating "usual" seekbar -->
		<attr name="forceValue" format="float"/>
		
		<!-- Used only for layout=scroll. Default=true. If true, leftmost/rightmost bars are gradually faded out/in -->
		<attr name="fadeSidebars" format="boolean"/>

		<!-- Time for data change animation in ms -->
		<attr name="dataAnimTime" format="integer"/>
		<!-- Time for data change animation when no incoming data exists (to small line) in ms -->
		<attr name="noDataAnimTime" format="integer"/>
		
		<!-- Waveseek supports style "enabled" attribute (not supported by Android views by default). If set to false, waveseek functionality will be completely disabled -->
		<attr name="android:enabled"/>
	</declare-styleable>
			
</resources>